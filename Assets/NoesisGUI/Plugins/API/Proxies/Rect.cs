//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Rect {

  [MarshalAs(UnmanagedType.R4)]
  private float _x;

  [MarshalAs(UnmanagedType.R4)]
  private float _y;

  [MarshalAs(UnmanagedType.R4)]
  private float _width;

  [MarshalAs(UnmanagedType.R4)]
  private float _height;

  public Rect(float x, float y, float width, float height) {
    if (width < 0.0f || height < 0.0f) {
      throw new ArgumentException("Width and Height cannot be negative");
    }
    _x = x;
    _y = y;
    _width = width;
    _height = height;
  }

  public Rect(Point p0, Point p1) {
    _x = Math.Min(p0.X, p1.X);
    _y = Math.Min(p0.Y, p1.Y);

    _width = Math.Max(Math.Max(p0.X, p1.X) - _x, 0.0f);
    _height = Math.Max(Math.Max(p0.Y, p1.Y) - _y, 0.0f);
  }

  public Rect(Point p, Vector v) : this(p, p + v) {
  }

  public Rect(Size size) {
    if (size.IsEmpty) {
      this = _empty;
    }
    else {
      _x = _y = 0.0f;
      _width = size.Width;
      _height = size.Height;
    }
  }

  public Rect(Point location, Size size) {
    if (size.IsEmpty) {
      this = _empty;
    }
    else {
      _x = location.X;
      _y = location.Y;
      _width = size.Width;
      _height = size.Height;
    }
  }

  public static Rect Empty {
    get { return _empty; }
  }

  public bool IsEmpty {
    get { return _width < 0.0f; }
  }

  public Point Location {
    get { return new Point(_x, _y); }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      _x = value.X;
      _y = value.Y;
    }
  }

  public Size Size {
    get { return new Size(_width, _height); }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      _width = value.Width;
      _height = value.Height;
    }
  }

  public float X {
    get { return _x; }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      _x = value;
    }
  }

  public float Y {
    get { return _y; }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      _y = value;
    }
  }

  public float Width {
    get { return _width; }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      if (value < 0.0f) {
        throw new ArgumentException("Width cannot be negative");
      }
      _width = value;
    }
  }

  public float Height {
    get { return _height; }
    set {
      if (IsEmpty) {
        throw new InvalidOperationException("Empty Rect cannot be modified");
      }
      if (value < 0.0f) {
        throw new ArgumentException("Height cannot be negative");
      }
      _height = value;
    }
  }

  public float Left {
    get { return X; }
  }

  public float Right {
    get { return IsEmpty ? Single.NegativeInfinity : X + Width; }
  }
  
  public float Top {
    get { return Y; }
  }

  public float Bottom {
    get { return IsEmpty ? Single.NegativeInfinity : Y + Height; }
  }

  public Point TopLeft {
    get { return new Point(Left, Top); }
  }

  public Point TopRight {
    get { return new Point(Right, Top); }
  }

  public Point BottomLeft {
    get { return new Point(Left, Bottom); }
  }

  public Point BottomRight {
    get { return new Point(Right, Bottom); }
  }

  public bool Contains(float x, float y) {
    if (IsEmpty) {
      return false;
    }
    return x >= _x && x <= _x + _width && y >= _y && y <= _y + _height;
  }

  public bool Contains(Point point) {
    return Contains(point.X, point.Y);
  }

  public bool Contains(Rect rect) {
    if (IsEmpty || rect.IsEmpty) {
      return false;
    }
    return rect._x >= _x && rect._x + rect._width <= _x + _width &&
           rect._y >= _y && rect._y + rect._height <= _y + _height;
  }

  public bool IntersectsWith(Rect rect) {
    if (IsEmpty || rect.IsEmpty) {
      return false;
    }
    return rect._x <= _x + _width && rect._x + rect._width >= _x &&
           rect._y <= _y + _height && rect._y + rect._height >= _y;
  }

  public void Intersect(Rect rect) {
    if (!IntersectsWith(rect)) {
      this = Empty;
    }
    else {
      float left = Math.Max(Left, rect.Left);
      float top = Math.Max(Top, rect.Top);
      _width = Math.Max(Math.Min(_x + _width, rect._x + rect._width) - left, 0.0f);
      _height = Math.Max(Math.Min(_y + _height, rect._y + rect._height) - top, 0.0f);
      _x = left;
      _y = top;
    }
  }

  public static Rect Intersect(Rect r0, Rect r1) {
    r0.Intersect(r1);
    return r0;
  }

  public void Union(Rect rect) {
    if (IsEmpty) {
      this = rect;
    }
    else if (!rect.IsEmpty)
    {
      float left = Math.Min(Left, rect.Left);
      float top = Math.Min(Top, rect.Top);
      if (Single.IsPositiveInfinity(_width) ||
          Single.IsPositiveInfinity(rect._width)) {
          _width = Single.PositiveInfinity;
      }
      else {
          float right = Math.Max(_x + _width, rect._x + rect._width);
          _width = Math.Max(right - left, 0.0f);
      }
      if (Single.IsPositiveInfinity(_height) ||
          Single.IsPositiveInfinity(rect._height)) {
          _height = Single.PositiveInfinity;
      }
      else {
          float bottom = Math.Max(_y + _height, rect._y + rect._height);
          _height = Math.Max(bottom - top, 0.0f);
      }
      _x = left;
      _y = top;
    }
  }

  public static Rect Union(Rect r0, Rect r1) {
    r0.Union(r1);
    return r0;
  }

  public void Union(Point point) {
    Union(new Rect(point, point));
  }

  public static Rect Union(Rect rect, Point point) {
    rect.Union(new Rect(point, point));
    return rect;
  }

  public void Offset(float x, float y) {
    if (IsEmpty) {
      throw new InvalidOperationException("Empty Rect cannot be modified");
    }
    _x += x;
    _y += y;
  }

  public void Offset(Vector offset) {
    Offset(offset.X, offset.Y);
  }

  public static Rect Offset(Rect rect, float x, float y) {
    rect.Offset(x, y);
    return rect;
  }

  public static Rect Offset(Rect rect, Vector offset) {
    rect.Offset(offset.X, offset.Y);
    return rect;
  }

  public void Inflate(float width, float height) {
    if (IsEmpty) {
      throw new InvalidOperationException("Empty Rect cannot be modified");
    }
    _x -= width;
    _y -= height;
    _width += width; _width += width;
    _height += height; _height += height;
    if (_width < 0.0f || _height < 0.0f) {
      this = _empty;
    }
  }

  public void Inflate(Size size) {
    Inflate(size.Width, size.Height);
  }

  public static Rect Inflate(Rect rect, float width, float height) {
    rect.Inflate(width, height);
    return rect;
  }

  public static Rect Inflate(Rect rect, Size size) {
    rect.Inflate(size.Width, size.Height);
    return rect;
  }

  public static Rect Transform(Rect rect, Matrix matrix) {
    rect.Transform(matrix);
    return rect;
  }

  public void Transform(Matrix matrix) {
    Point p0 = matrix.Transform(TopLeft);
    Point p1 = matrix.Transform(TopRight);
    Point p2 = matrix.Transform(BottomRight);
    Point p3 = matrix.Transform(BottomLeft);

    _x = Math.Min(Math.Min(p0.X, p1.X), Math.Min(p2.X, p3.X));
    _y = Math.Min(Math.Min(p0.Y, p1.Y), Math.Min(p2.Y, p3.Y));
    _width = Math.Max(Math.Max(p0.X, p1.X), Math.Max(p2.X, p3.X)) - _x;
    _height = Math.Max(Math.Max(p0.Y, p1.Y), Math.Max(p2.Y, p3.Y)) - _y;
  }

  public void Transform(Matrix4 matrix) {
    if (Matrix4.IsAffine(matrix) && matrix[0][2] == 0.0f && matrix[1][2] == 0.0f && matrix[2][2] == 1.0f) {
      Vector v0 = matrix[0].XY;
      Vector v1 = matrix[1].XY;
      Vector v2 = matrix[3].XY;
      Transform(new Matrix(v0.X, v0.Y, v1.X, v1.Y, v2.X, v2.Y));
    }
    else {
      Vector4 tlp = new Vector4(Left, Top, 0.0f, 1.0f) * matrix;
      Vector4 trp = new Vector4(Right, Top, 0.0f, 1.0f) * matrix;
      Vector4 blp = new Vector4(Right, Bottom, 0.0f, 1.0f) * matrix;
      Vector4 brp = new Vector4(Left, Bottom, 0.0f, 1.0f) * matrix;

      Point p0 = new Point(tlp.X / tlp.W, tlp.Y / tlp.W);
      Point p1 = new Point(trp.X / trp.W, trp.Y / trp.W);
      Point p2 = new Point(blp.X / blp.W, blp.Y / blp.W);
      Point p3 = new Point(brp.X / brp.W, brp.Y / brp.W);

      _x = Math.Min(Math.Min(p0.X, p1.X), Math.Min(p2.X, p3.X));
      _y = Math.Min(Math.Min(p0.Y, p1.Y), Math.Min(p2.Y, p3.Y));
      _width = Math.Max(Math.Max(p0.X, p1.X), Math.Max(p2.X, p3.X)) - _x;
      _height = Math.Max(Math.Max(p0.Y, p1.Y), Math.Max(p2.Y, p3.Y)) - _y;
    }
  }

  public void Scale(float scaleX, float scaleY) {
    if (scaleX < 0.0f) {
      Width *= -scaleX;
      X = X * scaleX - Width;
    }
    else {
      Width *= scaleX;
      X *= scaleX;
    }
    if (scaleY < 0.0f) {
      Height *= -scaleY;
      Y = Y * scaleY - Height;
    }
    else {
      Height *= scaleY;
      Y *= scaleY;
    }
  }

  public static bool operator==(Rect r0, Rect r1) {
    return r0.X == r1.X && r0.Y == r1.Y && r0.Width == r1.Width && r0.Height == r1.Height;
  }

  public static bool operator!=(Rect r0, Rect r1) {
    return !(r0 == r1);
  }

  public bool Equals(Rect r0, Rect r1) {
    return r0 == r1;
  }

  public override bool Equals(Object obj) {
    return obj is Rect && this == (Rect)obj;
  }

  public bool Equals(Rect r) {
    return this == r;
  }

  public override int GetHashCode() {
    if (IsEmpty) {
      return 0;
    }
    else {
      return X.GetHashCode() ^ Y.GetHashCode() ^ Width.GetHashCode() ^ Height.GetHashCode();
    }
  }

  public override string ToString() {
    return String.Format("{0},{1},{2},{3}", X, Y, Width, Height);
  }

  public static Rect Parse(string str) {
    Rect r;
    if (Rect.TryParse(str, out r)) {
      return r;
    }
    throw new ArgumentException("Cannot create Rect from '" + str + "'");
  }

  #region Empty rect
  private static Rect CreateEmptyRect() {
    Rect empty = new Rect();
    empty._x = Single.PositiveInfinity;
    empty._y = Single.PositiveInfinity;
    empty._width = Single.NegativeInfinity;
    empty._height = Single.NegativeInfinity;
    return empty;
  }

  private static readonly Rect _empty = CreateEmptyRect();
  #endregion

  public static bool TryParse(string str, out Rect result) {
    bool ret = NoesisGUI_PINVOKE.Rect_TryParse(str != null ? str : string.Empty, out result);
    return ret;
  }

}

}

